{"data":{"site":{"siteMetadata":{"title":"Chandler Moisen","author":"Chandler Moisen"}},"markdownRemark":{"id":"e3ab0e45-fb18-5af5-afce-ba6f17ea0422","excerpt":"PurposeAs developers, the amount of on-the-job learning - from new technologies and programming techniques to design and product insights - continues to astoundâ€¦","html":"<h2>Purpose</h2>\n<p>As developers, the amount of on-the-job learning - from new technologies and programming techniques to design and product insights - continues to astound me.</p>\n<p>I am starting a series attempting to capture a few notable learning from each sprint of work in greater detail.</p>\n<p>Last sprint I encountered:</p>\n<ol>\n<li>Protocol buffers</li>\n<li>Bundling your own Ruby gems</li>\n<li>Bundling best practices</li>\n</ol>\n<h2>Protocol Buffers</h2>\n<p><a href=\"https://developers.google.com/protocol-buffers/\">Protocol buffers</a> (a.k.a. protobufs) are language-agnostic mechanisms for transmitting structured data. They allow interoperability between systems that might not share the same platforms or languages, and were designed with performance in mind.</p>\n<p>Data transfer presents a few problems: performance, compatibility, and type consistency.</p>\n<p>Protobufs address these issues by making use of pre-defined schema that declare the structure of the data you wish to transmit.</p>\n<p>Schemas look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">message Person {\n  required string name = 1;\n  required int32 id = 2;\n  optional string email = 3;\n}</code></pre></div>\n<ul>\n<li>\n<p>json and xml formats - readable - easy for humans to understand, easy to parse, self-contained</p>\n<ul>\n<li>high volume, serializing is expensive</li>\n<li>JSON has unclear types</li>\n<li>schema for this data structure is sent with every messsage!</li>\n</ul>\n</li>\n<li>\n<p>is json the best way to send data between servers</p>\n</li>\n<li>\n<p>schema used to encode and decode</p>\n</li>\n<li>\n<p>dive into schema + messages</p>\n<ul>\n<li>declaring a schema up front, both the encoder and decoder will have access to it</li>\n<li>no need to pass the field names, codes are used instead</li>\n<li>schema is also used to declare types</li>\n</ul>\n</li>\n<li>\n<p>proto are a binary format, need to compile</p>\n</li>\n<li>\n<p>JSON for browser and Protobuf for services</p>\n</li>\n<li>\n<p>advantages:</p>\n<ul>\n<li>lightweight - faster transmission</li>\n<li>validation of data structure</li>\n<li>easy to modify schema</li>\n</ul>\n</li>\n</ul>\n<h2>Bundling Ruby Gems</h2>\n<p>At General Assembly, we have a number of internal services built to handle things from authentication to AMQP. These internal services are release as Ruby gems so that we can easily implement them across our other services.</p>\n<p>This week I was able to </p>","frontmatter":{"title":"Sprint Learnings: One","date":"July 13, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/sprint_learnings_1/","previous":{"fields":{"slug":"/own-your-mistakes/"},"frontmatter":{"title":"Own Your Mistakes"}},"next":null}}