{"data":{"site":{"siteMetadata":{"title":"Chandler Moisen","author":"Chandler Moisen"}},"markdownRemark":{"id":"e3ab0e45-fb18-5af5-afce-ba6f17ea0422","excerpt":"PurposeAs developers, the amount of on-the-job learning - from new technologies and programming techniques to design and product insights - continues to astoundâ€¦","html":"<h2>Purpose</h2>\n<p>As developers, the amount of on-the-job learning - from new technologies and programming techniques to design and product insights - continues to astound me.</p>\n<p>I am starting a series attempting to capture a few notable learning from each sprint of work in greater detail.</p>\n<p>Last sprint I encountered:</p>\n<ol>\n<li>Protocol buffers</li>\n<li>Bundling your own Ruby gems</li>\n<li>Bundling best practices</li>\n</ol>\n<h2>Protocol Buffers</h2>\n<p><a href=\"https://developers.google.com/protocol-buffers/\">Protocol buffers</a> (a.k.a. protobufs) are language-agnostic mechanisms for transmitting structured data. They allow interoperability between systems that might not share the same platforms or languages, and were designed with performance in mind.</p>\n<!-- * data interchange format\n* useful in developing programs that communicate with each other\n* designed to be smaller and faster than XML\n* allows interoperability between platforms/languages or systems that might be needed in the future -->\n<p>Consider data transfer problems:</p>\n<ul>\n<li>\n<p>Performance of serializing</p>\n</li>\n<li>\n<p>Compatibility between systems</p>\n</li>\n<li>\n<p>data transfer problems</p>\n<ul>\n<li>type consistency</li>\n<li>compatibility</li>\n<li>performance</li>\n</ul>\n</li>\n<li>\n<p>programs often send / receive data from other programs   </p>\n</li>\n<li>\n<p>sending data considerations =></p>\n<ul>\n<li>protocol, format, size, and efficiency</li>\n<li>use of data?</li>\n</ul>\n</li>\n<li>\n<p>json and xml formats - readable - easy for humans to understand, easy to parse, self-contained</p>\n<ul>\n<li>high volume, serializing is expensive</li>\n<li>JSON has unclear types</li>\n<li>schema for this data structure is sent with every messsage!</li>\n</ul>\n</li>\n<li>\n<p>is json the best way to send data between servers</p>\n</li>\n<li>\n<p>schema used to encode and decode</p>\n</li>\n<li>\n<p>dive into schema + messages</p>\n<ul>\n<li>declaring a schema up front, both the encoder and decoder will have access to it</li>\n<li>no need to pass the field names, codes are used instead</li>\n<li>schema is also used to declare types</li>\n</ul>\n</li>\n<li>\n<p>proto are a binary format, need to compile</p>\n</li>\n<li>\n<p>JSON for browser and Protobuf for services</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>advantages:</p>\n<ul>\n<li>lightweight - faster transmission</li>\n<li>validation of data structure</li>\n<li>easy to modify schema</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"Sprint Learnings: One","date":"July 13, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/sprint_learnings_1/","previous":{"fields":{"slug":"/own-your-mistakes/"},"frontmatter":{"title":"Own Your Mistakes"}},"next":null}}