{"data":{"site":{"siteMetadata":{"title":"Chandler Moisen","author":"Chandler Moisen"}},"markdownRemark":{"id":"e3ab0e45-fb18-5af5-afce-ba6f17ea0422","excerpt":"PurposeAs developers the amount of on-the-job learning - from new technologies and programming techniques to design and product insights - continues to astoundâ€¦","html":"<h2>Purpose</h2>\n<p>As developers the amount of on-the-job learning - from new technologies and programming techniques to design and product insights - continues to astound me.</p>\n<p>Ideally, I would retain most of these learnings, but I am often moving at too quick a pace to absorb them.</p>\n<p>I am starting a series attempting to capture notable learnings from each sprint of work in greater detail.</p>\n<h2>Protocol Buffers</h2>\n<p><a href=\"https://developers.google.com/protocol-buffers/\">Protocol buffers</a> (a.ka. protobufs) are open-source language/platform-agnostic mechanisms, <a href=\"https://github.com/protocolbuffers/protobuf\">developed by Google</a>, for serializing structured data.</p>\n<ul>\n<li>\n<p>data interchange format</p>\n</li>\n<li>\n<p>useful in developing programs that communicate with each other</p>\n</li>\n<li>\n<p>designed to be smaller and faster than XML</p>\n</li>\n<li>\n<p>allows interoperability between platforms/languages or systems that might be needed in the future</p>\n</li>\n<li>\n<p>data transfer problems</p>\n<ul>\n<li>type consistency</li>\n<li>compatibility</li>\n<li>performance</li>\n</ul>\n</li>\n<li>\n<p>programs often send / receive data from other programs   </p>\n</li>\n<li>\n<p>sending data considerations =></p>\n<ul>\n<li>protocol, format, size, and efficiency</li>\n<li>use of data?</li>\n</ul>\n</li>\n<li>\n<p>json and xml formats - readable - easy for humans to understand, easy to parse, self-contained</p>\n<ul>\n<li>high volume, serializing is expensive</li>\n<li>JSON has unclear types</li>\n<li>schema for this data structure is sent with every messsage!</li>\n</ul>\n</li>\n<li>\n<p>is json the best way to send data between servers</p>\n</li>\n<li>\n<p>schema used to encode and decode</p>\n</li>\n<li>\n<p>dive into schema + messages</p>\n<ul>\n<li>declaring a schema up front, both the encoder and decoder will have access to it</li>\n<li>no need to pass the field names, codes are used instead</li>\n<li>schema is also used to declare types</li>\n</ul>\n</li>\n<li>\n<p>proto are a binary format, need to compile</p>\n</li>\n<li>\n<p>JSON for browser and Protobuf for services</p>\n</li>\n</ul>\n<ul>\n<li>\n<p>advantages:</p>\n<ul>\n<li>lightweight - faster transmission</li>\n<li>validation of data structure</li>\n<li>easy to modify schema</li>\n</ul>\n</li>\n</ul>\n<p>speed: <a href=\"https://auth0.com/blog/beating-json-performance-with-protobuf/\">https://auth0.com/blog/beating-json-performance-with-protobuf/</a></p>","frontmatter":{"title":"Sprint Learnings: Part One","date":"July 13, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/sprint_learnings_1/","previous":{"fields":{"slug":"/own-your-mistakes/"},"frontmatter":{"title":"Own Your Mistakes"}},"next":null}}