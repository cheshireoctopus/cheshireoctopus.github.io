[{"date":"06/12/2017","topics":["static-site-generator","personal blog","markdown-parser","markdown-to-html","react"],"title":"Roll Your Own Static Site","urlTitle":"roll_your_own_static_site","html":"<p><div class=\"post-image-container\"><img src=\"public/blog/roll_your_own_static_site/img/snoop.jpg\" alt=\"snoop dogg rolling\"/></div></p>\n<p>Recently I decided to rebuild my long neglected and dilapidated blog - previously powered by <a href=\"http://octopress.org/\">Octopress</a> - using JavaScript.</p>\n<p>As a blog is a perfect use case for a static site generator, I first investigated exisiting solutions, and found, as expected, there are already quite a few available:</p>\n<ul>\n<li><a href=\"http://www.metalsmith.io/\">Metalsmith</a></li>\n<li><a href=\"https://hexo.io/\">Hexo</a></li>\n<li><a href=\"http://wintersmith.io/\">Wintersmith</a></li>\n</ul>\n<p>See <a href=\"https://www.staticgen.com/\">https://www.staticgen.com/</a> for even more.</p>\n<p>While more than sufficient, I found these to be overkill as all I really needed was to <strong>convert some markdown into HTML</strong>.</p>\n<p>Add a pinch of CSS, maybe your favorite frontend view layer, and that&#39;s it - you&#39;re cruising.</p>\n<p>So, as any self-respecting dev would do, I rolled my own with React - check it out <a href=\"https://github.com/cheshireoctopus/cheshireoctopus.github.io\">here</a>.</p>\n<h2 id=\"structure\">Structure</h2>\n<p>The structure (simplified below) is pretty straight-forward:</p>\n<pre><code class=\"hljs undefined\">|-- app\n|    |-- components\n|    |-- index.js\n|    |-- posts.json\n|    |-- projects.json\n|-- bin\n|    |-- gen\n|-- public\n|    |-- blog\n|        |-- my_first_post\n|            |-- img\n|            |-- data.json\n|            |-- post.md\n|-- index.html\n|-- webpack.confg.js</code></pre><p><code>app/components/</code> holds all the <code>.jsx</code>, and uses <code>posts.json</code> - created via <code>bin/gen</code> (see below) - to populate the blog posts.</p>\n<p>Blog posts are stored as individual directories in <code>public/blog/</code>; each post directory contains:</p>\n<ul>\n<li><code>data.json</code></li>\n<li><code>post.md</code></li>\n<li><code>img/</code></li>\n</ul>\n<p><code>data.json</code> contains post-specific metadata (<code>title</code>, <code>date</code>, <code>topics</code>), while <code>post.md</code> contains the related markdown content; <code>img/</code> holds the post&#39;s images.</p>\n<p>See an example <a href=\"https://github.com/cheshireoctopus/cheshireoctopus.github.io/tree/master/public/blog/twilio_on_rails_sms_basics\">here</a>.</p>\n<p>Running <code>./bin/gen</code> from root parses through each post directory in <code>public/blog/</code>, transforms the <code>post.md</code> file into HTML, and then adds this string under the key <code>html</code> to the relative <code>data.json</code> object. Each JSON object is then pushed to an array and outputted at <code>app/posts.json</code> for use inside the React app.</p>\n<h2 id=\"markdown-to-html\">Markdown to HTML</h2>\n<p>The core of the blog is powered by a single shell script that rips through a bunch of markdown files, converting them into HTML:</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-meta\">#!/usr/bin/env node</span>\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">Promise</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'bluebird'</span>)\n<span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">Promise</span>.promisifyAll(<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>))\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>)\n<span class=\"hljs-keyword\">const</span> marked = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'marked'</span>)\n<span class=\"hljs-keyword\">const</span> highlightjs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'highlight.js'</span>)\n\n<span class=\"hljs-keyword\">const</span> PATH_TO_ROOT = path.join(__dirname, <span class=\"hljs-string\">'..'</span>)\n<span class=\"hljs-keyword\">const</span> PATH_TO_APP = path.join(PATH_TO_ROOT, <span class=\"hljs-string\">'app'</span>)\n<span class=\"hljs-keyword\">const</span> PATH_TO_SRC = path.join(PATH_TO_ROOT, <span class=\"hljs-string\">'public'</span>, <span class=\"hljs-string\">'blog'</span>)\n\n<span class=\"hljs-keyword\">const</span> renderer = <span class=\"hljs-keyword\">new</span> marked.Renderer()\nrenderer.code = <span class=\"hljs-function\">(<span class=\"hljs-params\">code, language</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> validLang = !!(language &amp;&amp; highlightjs.getLanguage(language))\n    <span class=\"hljs-keyword\">const</span> highlighted = validLang ? highlightjs.highlight(language, code).value : code\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`&lt;pre&gt;&lt;code class=\"hljs <span class=\"hljs-subst\">${language}</span>\"&gt;<span class=\"hljs-subst\">${highlighted}</span>&lt;/code&gt;&lt;/pre&gt;`</span>\n}\nrenderer.image = <span class=\"hljs-function\">(<span class=\"hljs-params\">src, title, alt</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`&lt;div class=\"post-image-container\"&gt;&lt;img src=\"<span class=\"hljs-subst\">${src}</span>\" alt=\"<span class=\"hljs-subst\">${alt}</span>\"/&gt;&lt;/div&gt;`</span>\n}\n\nmarked.setOptions({\n    renderer,\n})\n\nfs.readdirAsync(PATH_TO_SRC)\n    .then(<span class=\"hljs-function\"><span class=\"hljs-params\">posts</span> =&gt;</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.map(posts, postDir =&gt; {\n            <span class=\"hljs-keyword\">const</span> srcPostDir = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${PATH_TO_SRC}</span>/<span class=\"hljs-subst\">${postDir}</span>`</span>\n\n            <span class=\"hljs-keyword\">return</span> fs.readdirAsync(srcPostDir)\n                .then(<span class=\"hljs-function\"><span class=\"hljs-params\">files</span> =&gt;</span> {\n                    <span class=\"hljs-keyword\">const</span> readJSON = fs.readFileAsync(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${srcPostDir}</span>/data.json`</span>, <span class=\"hljs-string\">'utf8'</span>)\n                    <span class=\"hljs-keyword\">const</span> readMD = fs.readFileAsync(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${srcPostDir}</span>/post.md`</span>, <span class=\"hljs-string\">'utf8'</span>)\n\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.join(readJSON, readMD, (json, md, imgs) =&gt; {\n                        <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-built_in\">JSON</span>.parse(json)\n\n                        <span class=\"hljs-keyword\">return</span> {\n                            <span class=\"hljs-attr\">date</span>: data.date,\n                            <span class=\"hljs-attr\">topics</span>: data.topics,\n                            <span class=\"hljs-attr\">title</span>: data.title,\n                            <span class=\"hljs-attr\">urlTitle</span>: postDir,\n                            <span class=\"hljs-attr\">html</span>: marked(md),\n                        }\n                    })\n                })\n        })\n    })\n    .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">postCollection</span>) =&gt;</span> {\n        postCollection = postCollection.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(b.date) - <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(a.date)\n        })\n\n        fs.writeFileAsync(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${PATH_TO_APP}</span>/posts.json`</span>, <span class=\"hljs-built_in\">JSON</span>.stringify(postCollection))\n            .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Congratulations - generated <span class=\"hljs-subst\">${postCollection.length}</span> posts.`</span>))\n    })</code></pre><h2 id=\"bluebird-s-promisifyall-\">Bluebird&#39;s <code>.promisifyAll</code></h2>\n<p>A quick note: asynchronous file input/output can quickly lead to a labyrinth of callbacks. To help mitigate sphagetti code, you&#39;ll see that I leveraged <code>Bluebird.promisifyAll</code> (<a href=\"http://bluebirdjs.com/docs/api/promise.promisifyall.html\">documentation</a>) by wrapping Node&#39;s <code>fs</code> module:</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">Promise</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'bluebird'</span>)\n<span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">Promise</span>.promisifyAll(<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>))</code></pre><p><code>.promisifyAll</code> parses through an object, &quot;promisifying&quot; the object&#39;s methods. These new promises are accessed via the original method&#39;s name + a suffix of <code>Async</code>.</p>\n<p>For example, to read a directory using <code>fs</code>, one would typically call <code>fs.readdir</code>; when wrapped using <code>promisifyAll</code> one would call <code>fs.readdirAsync</code>.</p>\n<h2 id=\"marked-custom-parsers\">Marked: Custom Parsers</h2>\n<p>To convert markdown into HTML, I relied upon <a href=\"https://github.com/chjj/marked\">marked</a> and <a href=\"https://highlightjs.org/\">highlight.js</a>.</p>\n<p>While marked will convert markdown to HTML out of the box, it does require custom configuration when rendering code blocks and applying syntax highlighting. Thankfully, this process is pretty easy, thanks to hightlight.js.</p>\n<p>The majority of marked&#39;s configuration can be accessed via its <a href=\"https://github.com/chjj/marked#renderer\">marked.Renderer()</a> API. This allows the developer to define functions which are invoked when parsing certain <a href=\"https://github.com/chjj/marked#block-level-renderer-methods\">block</a> or <a href=\"https://github.com/chjj/marked#inline-level-renderer-methods\">inline</a> elements.</p>\n<p>For example, to apply custom markup to an image element, first instantiate a new <code>Renderer()</code> object, define an <code>image</code> method on this object describing what HTML should returned when parsing an image, and finally use <code>.setOptions</code> to apply the custom rendering.</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> marked <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'marked'</span>\n\n<span class=\"hljs-keyword\">const</span> renderer = <span class=\"hljs-keyword\">new</span> marked.Renderer()\n\nrenderer.image = <span class=\"hljs-function\">(<span class=\"hljs-params\">src, title, alt</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`&lt;div class=\"post-image-container\"&gt;&lt;img src=\"<span class=\"hljs-subst\">${src}</span>\" alt=\"<span class=\"hljs-subst\">${alt}</span>\"/&gt;&lt;/div&gt;`</span>\n}\n\nmarked.setOptions({\n    renderer,\n})</code></pre><p>Applying custom rendering to a code block would be similar, except you would utilize hightlight.js to apply syntax highlighting. Check out this <a href=\"http://shuheikagawa.com/blog/2015/09/21/using-highlight-js-with-marked/\">post</a> for some more detail.</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> marked <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'marked'</span>\n<span class=\"hljs-keyword\">import</span> highlightjs <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'highlight.js'</span>\n\n<span class=\"hljs-keyword\">const</span> renderer = <span class=\"hljs-keyword\">new</span> marked.Renderer()\n\nrenderer.code = <span class=\"hljs-function\">(<span class=\"hljs-params\">code, language</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> validLang = !!(language &amp;&amp; highlightjs.getLanguage(language))\n    <span class=\"hljs-keyword\">const</span> highlighted = validLang ? highlightjs.highlight(language, code).value : code\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`&lt;pre&gt;&lt;code class=\"hljs <span class=\"hljs-subst\">${language}</span>\"&gt;<span class=\"hljs-subst\">${highlighted}</span>&lt;/code&gt;&lt;/pre&gt;`</span>\n}\n\nmarked.setOptions({\n    renderer,\n})</code></pre><p>One caveat when hightlight.js - it does not ship with line numbers in code blocks. According to the library&#39;s author(s), this is <a href=\"http://highlightjs.readthedocs.io/en/latest/line-numbers.html\">&quot;not an oversight but a feature&quot;</a>, and it does appear that a <a href=\"https://github.com/wcoder/highlightjs-line-numbers.js/\">plugin</a> was built to add them in.</p>\n<h2 id=\"next-steps-improvements\">Next Steps + Improvements</h2>\n<ul>\n<li>Easier post creation via CLI</li>\n<li>Eventually, <code>posts.json</code> might become too large to treat as a single file</li>\n</ul>\n"},{"date":"01/23/2014","topics":["ruby on rails","gibbon","mailchimp"],"title":"MailChimp + Gibbon + Rails: Basic Mailing List Setup","urlTitle":"mailchimp_plug_gibbon_plus_rails_create_a_basic_sign_up_form","html":"<p><div class=\"post-image-container\"><img src=\"public/blog/mailchimp_plug_gibbon_plus_rails_create_a_basic_sign_up_form/img/logo.png\" alt=\"mailchip logo\"/></div></p>\n<p>You’ve made it to the big time when you want to start a mailing list. There are many ESP’s (email service providers) out there, each with respective strengths and weaknesses. I’d recommend checking into <a href=\"https://mailchimp.com/\">MailChimp</a> as they provide an “entrepreneur’s plan” that allows you to send 12,000 emails a month to 2,000 subscribers – <strong>for free, for life.</strong> And because I have no experience with any other ESP…</p>\n<p>This tutorial will cover MailChimp’s integration with Rails using the <a href=\"https://github.com/amro/gibbon\">Gibbon</a> gem. We will be building a simple Rails application that will display a form to collects users’ email addresses and add them to a MailChimp email list.</p>\n<p>It is assumed that you possess a basic/intermediate understanding of Ruby (v. 1.9.3) and Rails (v. 4.0.2).</p>\n<p><strong>Note:</strong> this tutorial covers MailChimp’s V2 of their API.</p>\n<hr>\n<h2 id=\"part-one-mailchimp\">Part One: MailChimp</h2>\n<p>Before we jump into Rails, we need to do three things: 1) obtain our API key, 2) make an email list with MailChimp; 3) obtain that list’s ID.</p>\n<p><strong>1)</strong> Once logged into your MailChimp account, look to the left, select your name, and then “Account Settings” in the popup menu. Next, click the “Extras” dropdown and select “API Keys”. Voilla, you have your API key.</p>\n<p><strong>2)</strong> To generate an email list, select “Lists” from the menu on the left. In the top-right corner, click “Create List” to begin the process. Hint: it’s relatively straight forward.</p>\n<p><strong>3)</strong> To get the ID of the list you just created, select “List” from the menu on the left. This displays a list of lists…Click on the name of your new list, then the “Settings” dropdown, and select “List name &amp; defaults”. Now you have your list ID. Super.</p>\n<hr>\n<h2 id=\"part-two-rails\">Part Two: Rails</h2>\n<p>The Rails integration involves five steps: 1) adding the Gibbon gem to your gemfile; 2) creating an intializer file; 3) generating a controller and 4) a view; and 5) configuring your routes.</p>\n<p><strong>1)</strong> Add the Gibbon gem to your gemfile and run bundle in your terminal. <a href=\"https://github.com/amro/gibbon\">Gibbon is an API wrapper for MailChimp’s Primary and Export APIs</a>, or, in other words, a chunk of code you can drop into your project and work with quickly. There are quite a few MailChimp API Wrappers spanning a variety of languages.</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-comment\">#Gemfile</span>\n\n\ngem <span class=\"hljs-string\">'gibbon'</span>, <span class=\"hljs-symbol\">git:</span> <span class=\"hljs-string\">'git://github.co/amro/gibbon.git'</span></code></pre><p>Take note: other <a href=\"http://mrgeorgegray.com/workflow/getting-a-grip-on-gibbon/\">tutorials</a> reported issues running the correct version of the gem. If you encounter a similar problem, try adding <code>git: ‘git://github.co/amro/gibbon.git’</code> to your gemfile so it points to the gem’s repository.</p>\n<p><strong>2)</strong> Create a new initializer file, ‘gibbon.rb’, in ‘config/initializers’ to declare your MailChimp API key and two other variables. Setting throws_exception to false will give you a pretty hash in the event of an error.</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-comment\">#config/initializers/gibbon.rb</span>\n\nGibbon::API.api_key = <span class=\"hljs-string\">\"YOUR-API-KEY\"</span>\nGibbon::API.timeout = <span class=\"hljs-number\">15</span>\nGibbon::API.throws_exceptions = <span class=\"hljs-literal\">false</span></code></pre><p><strong>3)</strong> Generate a controller <code>emailapi</code> to handle MailChimp’s API calls and create a method <code>subscribe</code> that will be responsible for taking users’ email input and pushing it to your mailing list.</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-comment\">#app/controllers/emailapi_controller.rb</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">index</span></span>\n<span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">subscribe</span></span>\n\n    @list_id = <span class=\"hljs-string\">\"YOUR-LIST-ID\"</span>\n    gb = Gibbon::API.new\n\n    gb.lists.subscribe({\n      <span class=\"hljs-symbol\">:id</span> =&gt; @list_id,\n      <span class=\"hljs-symbol\">:email</span> =&gt; {<span class=\"hljs-symbol\">:email</span> =&gt; params[<span class=\"hljs-symbol\">:email</span>][<span class=\"hljs-symbol\">:address</span>]}\n      })\n\n<span class=\"hljs-keyword\">end</span></code></pre><p>The variables <code>@list_id</code> and <code>gb</code> are respectively defined as the ID of the list you created (from Part One, remember?) and an instance of the API wrapper. The latter is pulling from the <code>app/config/initializers/gibbon.rb</code>.</p>\n<p>Next, we make an API call – <code>.lists.subscribe()</code> – on the instance itself. This call takes a hash as an argument, and in this hash, we pass two parameters: <code>:id</code>, associated with the ID of your list, and <code>:email</code>, associated with the user’s email (this will become clearer after we construct the view).</p>\n<p><strong>4)</strong> Having completed the controller, let’s make the corresponding view. Create a file <code>index.html.erb</code> in <code>/app/views/emailapi</code>.</p>\n<pre><code class=\"hljs ruby\">#app/views/emailapi/index.html.erb\n\n&lt;h1&gt;Get My Awesome News Letter&lt;/h1&gt;\n&lt;p&gt;Give me your email and keep up to date on my cat's thoughts.&lt;/p&gt;\n&lt;%= form_tag('/emailapi/subscribe', method: \"post\", id: \"subscribe\", remote: \"true\") do -%&gt;\n   &lt;%= email_field(:email, :address, {id: \"email\", placeholder: \"email address\"}) %&gt;\n   &lt;%= submit_tag(\"Sign me up!\") %&gt;\n&lt;% end %&gt;</code></pre><p>Beneath the <code>&lt;h1&gt;</code> and <code>&lt;p&gt;</code> html elements, use a Rails helper <code>form_tag</code> to create the sign up form. Pass in four paramaters:</p>\n<ol>\n<li>The action the form is going to take, or where the form will be submitted</li>\n<li>The HTML method defining how the action will occur, in this case <code>post</code></li>\n<li>The form’s ID</li>\n<li>Set <code>remote</code> to <code>true</code>, allowing unobtrusive JS drivers to modify the the form’s behavior.</li>\n</ol>\n<p>Lastl, the <code>submit_tag</code> method creates our <code>&lt;input&gt;</code> tags. Our form is rendered in HTML as seen below:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Get My Awesome News Letter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Give me your email and keep up to date on my cat's thoughts.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">accept-charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">\"/emailapi/subscribe\"</span> <span class=\"hljs-attr\">data-remote</span>=<span class=\"hljs-string\">\"true\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"subscribe\"</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"post\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"margin:0;padding:0;display:inline\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"utf8\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"hidden\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"&amp;#x2713;\"</span> /&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"email\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"email[address]\"</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"email address\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"email\"</span> /&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"commit\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Sign me up!\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></code></pre><p>To learn more about forms, check out the <a href=\"http://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html\">documentation</a>.</p>\n<p>For more information on the subscribe API call, check out the <a href=\"https://developer.mailchimp.com/documentation/mailchimp/reference/lists/members/#create-post_lists_list_id_members\">official documentation</a>.</p>\n<p><strong>5)</strong> Last, set your routes in <code>config/routes.rb</code>.</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-comment\">#config/routes.rb</span>\n\nroot <span class=\"hljs-string\">'emailapi#index'</span>\npost <span class=\"hljs-string\">'emailapi/subscribe'</span> =&gt; <span class=\"hljs-string\">'emailapi#subscribe'</span></code></pre><hr>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Alright, you should be good to go. Keep in mind, this tutorial barely scratches the surface of MailChimp + Rails + Gibbon.</p>\n"},{"date":"10/22/2013","topics":["ruby on rails","twilio","sms"],"title":"Twilio on Rails: SMS Basics","urlTitle":"twilio_on_rails_sms_basics","html":"<p><div class=\"post-image-container\"><img src=\"public/blog/twilio_on_rails_sms_basics/img/logo.png\" alt=\"twilio logo\"/></div></p>\n<p><a href=\"https://www.twilio.com/\">Twilio</a> is an awesome platform that makes it super easy to add SMS, voice, and VOIP functionality to your web applications.</p>\n<p>This tutorial will show you how to set up an extremely simple Ruby on Rails application that uses Twilio to send SMS messages from your browser. It’s probably best that you have a basic understanding of RoR.</p>\n<hr>\n<h2 id=\"twilio-setup\">Twilio Setup</h2>\n<p><strong>1:</strong> <a href=\"https://www.twilio.com/try-twilio\">Sign up</a> for free using a telephone number that you have access to – preferably your cell – as you will have to verify your account via SMS.</p>\n<p><strong>2:</strong> Twilio will automatically generate a telephone number for you. In my experience, these generated numbers are issued with the same area code as the original number you signed up with. <strong>Note:</strong> you can customize your number if you so wish.</p>\n<p>After you’ve made it through the login, you should be welcomed with this screen:</p>\n<p><div class=\"post-image-container\"><img src=\"public/blog/twilio_on_rails_sms_basics/img/twilio1.png\" alt=\"twilio home\"/></div></p>\n<p>Make a note of both the <strong>ACCOUNT SID</strong> and the <strong>AUTH TOKEN</strong> – you will need both of these later. To see the latter, click on the lock to view it.</p>\n<p><strong>3:</strong> I like to save my Twilio numbers in my cell because I have a terrible memory. As you can guess, I often forget to do even that. Visiting the ‘Numbers’ pane on the Twilio dashboard – pictured below – provide them for you.</p>\n<p><div class=\"post-image-container\"><img src=\"public/blog/twilio_on_rails_sms_basics/img/number.png\" alt=\"twilio number\"/></div></p>\n<hr>\n<h2 id=\"rails-setup\">Rails Setup</h2>\n<p><strong>1:</strong> First, create the Rails application, in this case thought-provokingly named ‘twilio_app’. We don’t need the <code>index.html</code> that Rails so graciously provides – toss it, you don’t need that noise.</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#bash</span>\n\nrails new twilio_app\nrm public/index.html</code></pre><p><strong>2:</strong> Twilio compiled a gem which makes Rails integration realtively painless. Check out the <a href=\"http://twilio-ruby.readthedocs.io/en/latest/\">documentation</a> and add it in the Gemfile. Make sure to bundle!</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-comment\">#Gemfile</span>\n\ngem <span class=\"hljs-string\">'twilio-ruby'</span></code></pre><p><strong>3:</strong> Next, we will generate a controller which will be responsbile for making sense of our app’s requests and producing the appropriate output. <strong>Note:</strong> this method of controller generation creates a bunch of extra files you do not need for this application, but it’s easy.</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#bash</span>\n\nrails g controller twilio</code></pre><p><strong>4:</strong> In the controller you just created, add a method <code>send_sms</code> which will send the SMS’s. We will come back to this in a moment.</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-comment\">#twilio_controller.rb</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TwilioController</span> &lt; ApplicationController</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">send_sms</span></span>\n  <span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-keyword\">end</span></code></pre><p><strong>5:</strong> We’re making headway on the backend, but we need do some barebones frontend functionality. Create a file <code>index.html.erb</code> that your Twilio controller has access to. Make sure this file is located in the following directory: <code>twilio_app/app/views/layouts</code>. In this file we are going to create a simple form which will allow the user to input a phone number and a message. Make sure the form’s action directs to <code>/send_sms</code> and the method is <code>POST</code>.</p>\n<pre><code class=\"hljs erb\"><span class=\"xml\"></span><span class=\"hljs-comment\">&lt;%# index.html.erb %&gt;</span><span class=\"xml\">\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>TWILIO!!!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">%=</span></span></span><span class=\"ruby\"> form_tag(<span class=\"hljs-string\">'/send_sms'</span>, <span class=\"hljs-symbol\">method:</span> <span class=\"hljs-string\">'POST'</span>) <span class=\"hljs-keyword\">do</span> </span><span class=\"xml\"><span class=\"hljs-tag\">%&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"enter number\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"number\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"enter message here\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"message\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">%</span></span></span><span class=\"ruby\"> <span class=\"hljs-keyword\">end</span> </span><span class=\"xml\"><span class=\"hljs-tag\">%&gt;</span></span></code></pre><p>Your <code>index.html.erb</code> should look like this:</p>\n<p><div class=\"post-image-container\"><img src=\"public/blog/twilio_on_rails_sms_basics/img/index.png\" alt=\"index.html.erb page\"/></div></p>\n<p><strong>6:</strong> Now that we’ve made our view and controller, let’s connect them via <code>routes.rb</code>. Clear out the comments in the <code>routes.rb</code> file, build a root path that directs to <code>index.html.erb</code>, and then another path that will post the information from the form we just built to the <code>send_sms</code> method in the Twilio controller.</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-comment\">#routes.rb</span>\n\nTwilioApp::Application.routes.draw <span class=\"hljs-keyword\">do</span>\n\n  root <span class=\"hljs-symbol\">:to</span> =&gt; <span class=\"hljs-string\">'twilio#index'</span>\n  post <span class=\"hljs-string\">'/send_sms'</span> =&gt; <span class=\"hljs-string\">'twilio#send_sms'</span>\n\n<span class=\"hljs-keyword\">end</span></code></pre><p><strong>7:</strong> Alright, last step. Do you still remember your <strong>ACCOUNT SID</strong>, <strong>AUTH TOKEN</strong>, and <strong>Twilio phone number</strong>? We’re going to add these to our Twilio controller’s <code>send_sms</code> method to enable our application to send texts.</p>\n<p>I’ll show you my code, then walk you through it line by line.</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-comment\">#twilio_controller.rb</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TwilioController</span> &lt; ApplicationController</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">send_sms</span></span>\n        message = params[<span class=\"hljs-symbol\">:message</span>]\n        number = params[<span class=\"hljs-symbol\">:number</span>]\n        account_sid = <span class=\"hljs-string\">'XXXyour account sid should be hereXXX'</span>\n        auth_token = <span class=\"hljs-string\">'XXXyour auth token should be hereXXX'</span>\n\n        @client = Twilio::REST::Client.new account_sid, auth_token\n        @message = @client.account.messages.create({\n            <span class=\"hljs-symbol\">:to</span> =&gt; <span class=\"hljs-string\">\"+1\"</span>+<span class=\"hljs-string\">\"<span class=\"hljs-subst\">#{number}</span>\"</span>,\n            <span class=\"hljs-symbol\">:from</span> =&gt; <span class=\"hljs-string\">\"+12813308004\"</span>,\n            <span class=\"hljs-symbol\">:body</span> =&gt; <span class=\"hljs-string\">\"<span class=\"hljs-subst\">#{message}</span>\"</span>\n        })\n        redirect_to <span class=\"hljs-string\">'/'</span>\n    <span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-keyword\">end</span></code></pre><p><strong>Line 1:</strong> Opens the TwilioController</p>\n<p><strong>Line 3:</strong> Defines the <code>send_sms</code> method</p>\n<p><strong>Line 4:</strong> Takes the message input from the form in <code>index.html.erb</code> as a paramater and assigns it to the variable ‘message’</p>\n<p><strong>Line 5:</strong> Takes the number input from the form in <code>index.html.erb</code> as a paramater and assigns it to the variable <code>number</code></p>\n<p><strong>Line 6:</strong> Stores your <strong>ACCOUNT_SID</strong> as a variable</p>\n<p><strong>Line 7:</strong> Stores your <strong>AUTH_TOKEN</strong> as a variable</p>\n<p><strong>Line 9:</strong> Instatiates a Twilio Rest Client as <code>@client</code>, which stores the authentication parameters on lines 6 and 7 (account_sid and auth_token, respectively), and enables the <code>send_sms</code> method to make HTTP request to Twilio. <a href=\"http://www.rubydoc.info/github/twilio/twilio-ruby/Twilio/REST/Client\">More info…</a></p>\n<p><strong>Line 11-13:</strong> Creates a message, stored as the variable <code>@message</code>, which takes a hash as an argument. The hash should include: <code>:to</code>, <code>:from</code>, and <code>:body</code>. <code>:to</code> interpolates the variable number, and represents the recipeint of the SMS. <code>:from</code> should be your Twilio number stored in the following format: <code>+12813308004</code>. <code>:body</code> interpolates the message variable which contains the message entered on <code>index.html.erb</code>.</p>\n<p><strong>Line 14:</strong> After the SMS is processed and sent, this redirects the user back to the root directory, or, in our case, <code>index.html.erb</code>.</p>\n<hr>\n<h2 id=\"outcome\">Outcome</h2>\n<p>Assuming the code is correct, run the application locally and send yourself a message.</p>\n<p>If everything works out, you should be able to send SMS messages from your browser!</p>\n<p><div class=\"post-image-container\"><img src=\"public/blog/twilio_on_rails_sms_basics/img/example.png\" alt=\"twilio cat\"/></div></p>\n<hr>\n<h2 id=\"caveats\">Caveats</h2>\n<p>As this application was developed using Twilio’s free service, you can only send texts to the phone number that you verified your Twilio account with. To mess with your friends, activate your Twilio account by adding a credit card. Individual texts cost less than $.01.</p>\n<hr>\n<h2 id=\"next-steps\">Next Steps</h2>\n<p>One day I will write a follow up, but for now, check out this <a href=\"https://github.com/crtr0/twilio-rails-demo\">github repo</a> for an idea of where else you can take Twilio and Rails.</p>\n"}]